Getting Started
Now it's time to learn the ASP.NET Core Mvc syntax. This requires more setup than NancyFx did, but it comes with a lot more power and versatility. As always, in order to configure your project we start with project.json:

{
  "buildOptions": {
    "emitEntryPoint": true
  },
  "dependencies": {
     "Microsoft.NETCore.App": {
        "type": "platform",
        "version": "1.0.1"
      },
      "Microsoft.AspNetCore.Server.Kestrel": "1.0.0",
      "Microsoft.AspNetCore.Mvc": "1.0.0"
  },
  "frameworks": {
    "netcoreapp1.0": {
      "dependencies": {}
    }
  }
}
After a dotnet restore we now have the Mvc tools available for our project. Configuration is not done yet though! We still have to tell our app to use these tools. Create a Startup.cs file and put the following code into it:

using Microsoft.Extensions.DependencyInjection;
namespace YourNamespace
{
    public class Startup
    {
        public void ConfigureServices(IServiceCollection services)
        {
            services.AddMvc();
        }
    }
}
Program.cs will look the same as it did previously, go ahead and copy it over from an older assignment.
At its most basic that's all we need to activate the Mvc, however we still need to learn how to apply the new tools at our command. 


Controllers
Now that we have ASP.NET Core Mvc configured it's time to put it into use. The next step is to create a controller. Controllers live in a folder called Controllers. Our example controller will be called "HelloController":



Copy the following code into your new controller:

using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
namespace YourNamespace.Controllers
{
 public class HelloController : Controller
 {
  [HttpGet]
  public Task Index()
  {
   return Response.WriteAsync("Hello World!");
  }
 }
}
Now we have to set up a route that will connect to our controller method. Open up your Startup.cs and add a new method called "Configure"

public void Configure(IApplicationBuilder App)
        {
            App.UseMvc( routes =>
            {
                routes.MapRoute(
                    name: "Default", // The route's name is only for our own reference
                    template: "", // The pattern that the route matches
                    defaults: new {controller = "Hello", action = "Index"} // The controller and method to execute
                );
            });
        }
If you run your code now you"ll see the message "Hello World!" displayed in the browser. But we don't make controllers that just show a string in the browser very often do we? We want to serve up view files! We'll learn how in the next tab.

Routing
ASP.NET Core Mvc has some of the simplest routing of any full MVC framework.

...
// A GET method
[HttpGet]
[Route("index")]
public IActionResult Index()
{
 ...
}
// A POST method
[HttpPost]
[Route("")]
public IActionResult Other()
{
 ...
}
[HttpGet] is optional on GET routes, but all POST routes must have an [HttpPost] before them. A route of Route("template") will match the url localhost:5000/template.

We can also accept parameters in our routes:

...
[HttpGet]
[Route("template/{Name}")]
public IActionResult Method(string Name)
{
 ...
}
Be aware, if your method expects to receive a parameter through the url it will break if it doesn't receive one.

Now add a route to your controller and run your code. you"ll see the message "Hello World!" displayed in the browser. But we don't make controllers that just show a string in the browser very often do we? We want to serve up view files! We'll learn how in the next tab.


Serving View Files
ASP.NET Core makes serving views a breeze. The framework comes equipped with powerful tools for finding your views wherever they may be. All of our views will be .cshtml files, which are capable of running embedded C# code by default. We'll make more use of this power later, for now let's just try serving up a static page.



Even though we're only working with static HTML here, we still need a .cshtml file because ASP.NET Core Mvc will not read a standard .html file without extra configuration. This enables the framework to compile the HTML and therefore detect changes in it, so we don't have to trick it like we did with Nancy. it only takes one line in our project.json to serve html:

...
  "buildOptions": {
    ...
    "preserveCompilationContext": true
  }
...
preserveCompilationContext tells the compiler to bring along all of our view files.

Let's make some content to display.

Inside Index.cshtml:

<!DOCTYPE html>
<html>
    <head>
        <meta charset='utf-8'>
        <title></title>
        <link rel="stylesheet" href="~/css/style.css"/>
    </head>
    <body>
        <h1>Hello ASP.NET Mvc!</h1>
    </body>
</html>
Now we need to tell our controller to actually serve the view.

using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
namespace YourNamespace.Controllers
{
 public class HelloController : Controller
 {
  [HttpGet]
  [Route("...")]
  public IActionResult Index()
  {
   return View();
   //OR
   return View("Index");
   //OR
   return View("Index.cshtml");
  }
 }
}
ASP.NET Core Mvc is very flexible when it comes to designating our targeted view. If we have an empty View() then it will look for a view with the same name as the method serving the view. We can also specify the name of the file with or without an extension.

Now let's add a tiny bit of styling. Create a folder structure that looks like this.



The name wwwroot is a convention that tells the compiler where to find static content other than views, and the folder name inside corresponds to the name of our controller.

In our style.cssfile:

h1{
    color: red;
}
If we restore and run our project we'll see our html displayed on the browser, but the color from our css isn't being displayed. Don't worry, the solution is easy. With another dependency and one line in our configuration we can get rid of the issue forever. In our project.json:

...
  "dependencies": {
      ...
      "Microsoft.AspNetCore.StaticFiles": "1.0.0"
...
Next we have to configure our project to use this new dependency. That means it's time to move over to the Startup.cs file.

public void Configure(IApplicationBuilder App)
{
    App.UseStaticFiles();
    ...
}
Run restore again and then run the project, you should see the styling appear as expected. This is also how we include images, javascript, or any other static files other than views.